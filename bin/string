#!/bin/sh
# shellcheck disable=SC2120,SC3043

die()    { local err="$1"; shift; warn "$@"; exit "$err"; }
say()    { printf '%s\n' "$@"; }
warn()   { say "$@" >&2; }
noop()   { :; }
is_cmd() { command -v "$1" >/dev/null 2>&1; }
is_cmd local || alias local=noop

str_transform() {
  local str newstr line err o_help o_quiet o_bad

  # Parse options.
  while [ "$#" -gt 0 ]; do
    case "$1" in
      -h|--help)  o_help=true;  shift ;;
      -q|--quiet) o_quiet=true; shift ;;
      --)         shift;        break ;;
      -*)         o_bad="$1";   shift ;;
      *)                        break ;;
    esac
  done

  # Check usage.
  if [ -n "$o_help" ]; then
    printf 'string %s [-h | --help] [-q | --quiet] [STRING ...]\n' "$TRANSFORM"
    return 0
  elif [ -n "$o_bad" ]; then
    printf >&2 'string %s: %s: unknown option\n' "$TRANSFORM" "$o_bad"
    return 2
  fi

  # Collect piped input
  if ! [ -t 0 ]; then
    while IFS= read -r line || [ -n "$line" ]; do
      set -- "$@" "$line"
    done
  fi

  # Transform strings and return success only if any were transformed.
  err=1
  for str in "$@"; do
    if [ "$TRANSFORM" = "upper" ]; then
      newstr="$(printf '%s\n' "$str" | tr "[:lower:]" "[:upper:]")"
    else
      newstr="$(printf '%s\n' "$str" | tr "[:upper:]" "[:lower:]")"
    fi
    [ "$str" != "$newstr" ] && err=0
    [ -z "$o_quiet" ] && printf '%s\n' "$newstr"
  done
  return $err
}

string_upper() {
  TRANSFORM=upper str_transform "$@"
}

string_lower() {
  TRANSFORM=lower str_transform "$@"
}

string_length() {
  local err str len line o_help o_quiet o_bad

  while [ "$#" -gt 0 ]; do
    case "$1" in
      -h|--help)  o_help=true;  shift ;;
      -q|--quiet) o_quiet=true; shift ;;
      --)         shift;        break ;;
      -*)         o_bad="$1";   shift ;;
      *)                        break ;;
    esac
  done

  # Check usage.
  if [ -n "$o_help" ]; then
    printf '%s\n' 'string length [-h | --help] [-q | --quiet] [STRING ...]'
    return 0
  elif [ -n "$o_bad" ]; then
    printf >&2 'string length: %s: unknown option\n' "$o_bad"
    return 2
  fi

  # Collect piped input
  if ! [ -t 0 ]; then
    while IFS= read -r line || [ -n "$line" ]; do
      set -- "$@" "$line"
    done
  fi

  # Print lengths
  err=1
  for str in "$@"; do
    len="${#str}"
    [ "$len" -gt 0 ] && err=0
    [ -z "$o_quiet" ] && printf '%s\n' "$len"
  done
  return "$err"
}

string() {
  local cmd

  if [ $# -eq 0 ]; then
    die 1 "string: missing subcommand"
  elif is_cmd "string_$1"; then
    cmd="string_$1"
    shift
    "$cmd" "$@"
  else
    die 1 "string: invalid subcommand '$1'."
  fi
}
string "$@"
