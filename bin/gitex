#!/bin/sh
# optionally, !/usr/bin/env dash
##? gitex - git extensions; useful for making git aliases that don't suck
##? usage: gitx <subcommand>
##?

#region Helpers

# For testing...
gitex_foo() {
  echo "foo called with $# params: $@"
}

# POSIX test for function existance.
is_function() {
  [ "$#" -eq 1 ] || return 1
  type "$1" | sed "s/$1//" | grep -qwi function
}

# Move the last arg into the $1 position and cycle the rest forward in order.
# This is accomplished by cycling each arg one-by-one from the front to the back. Right
# before the final move, the last arg will be the first, and the rest will be shifted
# forward one (ie: 1 2 3 4 => 4 1 2 3). This will let you `set` new args, and then
# `shift` the one that was in the last position, which is conveniently now $1.
pop_prep() {
  local i=0
  while [ $((i+=1)) -lt $# ]; do
    set -- "$@" "$1"
    shift
  done
  printf '%s\n' "$@"
}

 # Take a repo and make it into the short user/repo form.
to_short_repo() {
  [ $# -eq 1 ] || return 1
  local default_user="$(git config gitex.gitUser || git config user.name || whoami)"
  # Prepend default git user to always make 2+ fields and print user/repo form
  echo "${default_user}/${1}" | awk -F '[/:]' '{ print $(NF-1) "/" $NF }'
}

# Take a repo and determine its clone destination.
to_repo_dir() {
  [ $# -eq 1 ] || return 1
  # Get the default repo dir, replacing ~ with $HOME
  local dir="$( (git config gitex.repoPath || echo $HOME/repos) | sed -e 's|^~|'$HOME'|' )"
  echo "${dir}/$( to_short_repo $1 )"
}

# Take a repo and determine its URL.
to_repo_url() {
  [ $# -eq 1 ] || return 1
  case $1 in (https://*|git@*) echo $1; return ;; esac

  local gitdomain gitprotocol repo
  gitdomain="$( git config gitex.gitDomain || echo 'github.com' )"
  gitprotocol="$( git config gitex.gitProtocol || echo 'https' )"
  repo="$( to_short_repo $1 )"

  case $gitprotocol in
    (ssh*|git*)
      echo "${gitprotocol}@${gitdomain}:${repo}.git"
      ;;
    (*)
      echo "${gitprotocol}://${gitdomain}/${repo}"
      ;;
  esac
}

#endregion

##? help: Display gitex help comments
gitex_help() {
  # echo "$0"
  grep "^##?" $0 | cut -c 5-
}

##? branch-cleanup: Remove branches no longer on remote
gitex_branch_cleanup() {
  # https://stackoverflow.com/questions/7726949/remove-tracking-branches-no-longer-on-remote
  local defbranch="$(gitex_branch_main 2>/dev/null)"
  git checkout ${defbranch:-main} &>/dev/null && git fetch -p && git branch -vv |
    awk '/: gone]/{print $1}' |
    xargs git branch -d
}

##? branch-main: Get the name of the default branch for a repo (main, master, trunk, etc)
gitex_branch_main() {
  # https://stackoverflow.com/questions/28666357/git-how-to-get-default-branch
  git symbolic-ref --short refs/remotes/origin/HEAD | sed 's|^origin/||'
}

##? branch-name: Get the current branch name
gitex_branch_name() {
  git branch --show-current
}

##? browse: Open web browser to git remote URL
gitex_browse() {
  local url=$(
    git config remote.${1:-origin}.url |
      sed -e 's|^.*@|https://|' -e 's|.git$||' -e 's|:|/|2'
  )
  git web--browse $url
}

##? checkout-branches: Checkout and track all branches
gitex_checkout_branches() {
  # https://stackoverflow.com/questions/67699/how-to-clone-all-remote-branches-in-git
  git branch -a | sed -n "/\\/HEAD /d; /\\/main$/d; /\\/master$/d; /remotes/p;" | xargs -L1 git checkout --track
}

##? cloner: A better git cloner.
# - Support short user/repo form
# - Default clone to ~/repos (configurable), not $PWD unless dir arg provided
# - Add flags I always forget but 99% of the time want (--recurse-submodules)
gitex_cloner() {
  if [ $# -eq 0 ]; then
    echo >&2 "clone: Expecting a repo argument. See 'git clone -h'."
    return 1
  fi

  local dir repo addflags debug

  # If there are multiple args, then the last arg could either be the repo, or the
  # optional destination path. If the latter, then pop_prep again. A final arg starting
  # with any of these symbols was likely intended to be a path not a repo: ~ / . $
  if [ $# -gt 1 ]; then
    set -- $(pop_prep "$@")
    case "$1" in
      ([./~\$]*)
        dir="$1" && shift
        set -- $(pop_prep "$@")
        ;;
    esac
  fi

  # Ensure we have an explicit clone destination set, and pop off the repo.
  [ -z "$dir" ] && dir="$( to_repo_dir "$1" )"
  repo="$( to_repo_url "$1" )"
  shift

  # Now, reassemble the git command, add any additional flags
  addflags="$( git config gitex.cloneAddFlags )"
  debug="$( git config gitex.debug | tr '[:upper:]' '[:lower:]' )"
  case $debug in
    (t|true|1)
      echo "clone command modified to:"
      echo "  command git clone $addflags $@ $repo $dir"
      ;;
  esac
  command git clone $addflags $@ $repo $dir
}

##? is-clean: Is the git repo clean
gitex_is_clean() {
  test -z "$(git status --porcelain 2>/dev/null)"
}

##? is-dirty: Is the git repo dirty
gitex_is_dirty() {
  test -n "$(git status --porcelain 2>/dev/null)"
}

##? lg: Print my preferred git log view.
gitex_lg() {
  git log --all --decorate --oneline --graph
}

##? log-pretty: Print a pretty log.
gitex_log_pretty() {
  git log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(auto)%d%C(reset)' --all
}

##? pushup: Push a new branch to the remote
gitex_pushup() {
  # Quick way to resolve the annoying error:
  #  'fatal: The current branch foo has no upstream branch.'
  # Or, you could just set `push.autoSetupRemote = true` in gitconfig...
  git push --set-upstream ${1:-origin} $(git rev-parse --abbrev-ref HEAD)
}

##? repodir: Print my preferred root repo directory.
gitex_repodir() {
  (git config gitex.repodir || echo $HOME/repos) | sed -e "s|^~|$HOME|"
}

##? sha: Print the 7-char short git SHA, with a * indicating dirty.
gitex_sha() {
  printf '%s' "$(git rev-parse --short HEAD)"
  gitex_is_dirty && echo '*' || echo
}

##? whoami: Print my config's username and email.
gitex_whoami() {
  git config user.name && git config user.email
}

# main gitex command
gitex() {
  if [ "$#" -eq 0 ]; then
    echo >&2 "gitex: expecting a subcommand."
    return 1
  fi

  local subcmd="$1"
  if [ "$subcmd" = "-h" ] || [ "$subcmd" = "--help" ]; then
    # Support -h/--help flags
    subcmd="help"
  else
    # Make kebab-case-subcommands work.
    subcmd=$(printf '%s' "$subcmd" | tr '-' '_')
  fi

  # Call the subcommand if it exists.
  if is_function "gitex_${subcmd}"; then
    shift
    "gitex_${subcmd}" "$@"
  else
    echo >&2 "gitex: subcommand not found '$subcmd'."
    return 1
  fi
}
gitex "$@"

# vim: set sw=2 sts=2 ts=8 et:
